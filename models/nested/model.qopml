functions {
  fun nonce() (create nonce);

  fun s_enc(data, key); 
  fun s_dec(data, key); 
  fun sign(data, s_key); 
  fun a_enc(data, p_key);
  fun a_dec(data, s_key);
  fun pkey(skey);
  fun skey();
  fun hash(data);
  
  fun id_c() (identification of Client);
  fun crit() (searching criteria);
  
  fun database() (creates non-encrypted database);
  fun key_request() (creates key request);
  fun get_db_key(key) (retrieving key for database);
  fun select_rows(database, criteria);
} 

equations {
  eq s_dec(s_enc(data, key), key) = data;
  eq a_dec(a_enc(data, pkey(skey)), skey) = data;
  
  eq get_db_key(key) = key;
}

channels {
  channel ch1,ch2,ch3,ch4 (*);
}

hosts {

 host Client(rr)(ch1, ch2) {
 
   #ID_C = id_c();
   #CRIT = crit();
 
   process Client1(ch1, ch2) {
     
     subprocess sc1() {
       M1 = (ID_C, CRIT);
     }
     
     subprocess sc2() {
       K_SESS = nonce();
       M1 = (ID_C, CRIT, K_SESS);
     }
     
     subprocess sc3() {
       K_SESS = nonce();
       M1 = (ID_C, CRIT, K_SESS);
     }
     
     out(ch1: M1);
     
     in(ch2: M2);
     
   }
 
 }
 
 host KeysStore(rr)(ch3, ch4) {
 
   #DB_KEY = nonce();
 
   process Store1(ch3, ch4) {
   
     while (true) {
       in (ch3: Request);
       KEY = get_db_key(DB_KEY);
       out(ch4: KEY);
     }
   }
 
 }
 
 host Server(rr)(ch1, ch2, ch3, ch4) {
 
   #DB_KEY = nonce();
   #DB = s_enc(database(), DB_KEY);
   #SK_S = skey();
 
   process Server1(ch1, ch2, ch3, ch4) {
   
     while(true) {
     in(ch1: M1);
     
     subprocess sc1_before_db() {
       CRIT = M1[1];
       
       subprocess scc() {
         subprocess scc1() {
         	stop;
       	 }
         stop;
       }
     }
     }
   }
 
 }

}